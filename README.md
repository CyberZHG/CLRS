# Introduction

[![travis-ci](https://travis-ci.org/CyberZHG/CLRS.svg)](https://travis-ci.org/CyberZHG/CLRS)
[![GitHub contributors](https://img.shields.io/github/contributors/CyberZHG/CLRS.svg)](https://github.com/CyberZHG/CLRS/graphs/contributors)

Some exercises and problems in __*Introduction to Algorithms (CLRS)*__ 3rd edition.

# Summary

## I Foundations

* 1 The Role of Algorithms in Computing
  * [1.1 Algorithms](Chapter_01_The_Role_of_Algorithms_in_Computing/exercises_1.1.ipynb)
  * [1.2 Algorithms as a technology](Chapter_01_The_Role_of_Algorithms_in_Computing/exercises_1.2.ipynb)
  * [Problems](Chapter_01_The_Role_of_Algorithms_in_Computing/problems.ipynb)

* 2 Getting Started
  * [2.1 Insertion sort](Chapter_02_Getting_Started/exercises_2.1.ipynb)
  * [2.2 Analyzing algorithms](Chapter_02_Getting_Started/exercises_2.2.ipynb)
  * [2.3 Designing algorithms](Chapter_02_Getting_Started/exercises_2.3.ipynb)
  * [Problems](Chapter_02_Getting_Started/problems.ipynb)

* 3 Growth of Functions
  * [3.1 Asymptotic notation](Chapter_03_Growth_of_Functions/exercises_3.1.ipynb)
  * [3.2 Standard notations and common functions](Chapter_03_Growth_of_Functions/exercises_3.2.ipynb)
  * [Problems](Chapter_03_Growth_of_Functions/problems.ipynb)

* 4 Divide-and-Conquer
  * [4.1 The maximum-subarray problem](Chapter_04_Divide_and_Conquer/exercises_4.1.ipynb)
  * [4.2 Strassen's algorithm for matrix multiplication](Chapter_04_Divide_and_Conquer/exercises_4.2.ipynb)
  * [4.3 The substitution method for solving recurrences](Chapter_04_Divide_and_Conquer/exercises_4.3.ipynb)
  * [4.4 The recursion-tree method for solving recurrences](Chapter_04_Divide_and_Conquer/exercises_4.4.ipynb)
  * [4.5 The master method for solving recurrences](Chapter_04_Divide_and_Conquer/exercises_4.5.ipynb)
  * [4.6 Proof of the master theorem](Chapter_04_Divide_and_Conquer/exercises_4.6.ipynb)
  * [Problems](Chapter_04_Divide_and_Conquer/problems.ipynb)

* 5 Probabilistic Analysis and Randomized Algorithms
  * [5.1 The hiring problem](Chapter_05_Probabilistic_Analysis_and_Randomized_Algorithms/exercises_5.1.ipynb)
  * [5.2 Indicator random variables](Chapter_05_Probabilistic_Analysis_and_Randomized_Algorithms/exercises_5.2.ipynb)
  * [5.3 Randomized algorithms](Chapter_05_Probabilistic_Analysis_and_Randomized_Algorithms/exercises_5.3.ipynb)
  * [5.4 Probabilistic analysis and further uses of indicator random variables](Chapter_05_Probabilistic_Analysis_and_Randomized_Algorithms/exercises_5.4.ipynb)
  * [Problems](Chapter_05_Probabilistic_Analysis_and_Randomized_Algorithms/problems.ipynb)


## II Sorting and Order Statistics

* 6 Heapsort
  * [6.1 Heaps](Chapter_06_Heapsort/exercises_6.1.ipynb)
  * [6.2 Maintaining the heap property](Chapter_06_Heapsort/exercises_6.2.ipynb)
  * [6.3 Building a heap](Chapter_06_Heapsort/exercises_6.3.ipynb)
  * [6.4 The heapsort algorithm](Chapter_06_Heapsort/exercises_6.4.ipynb)
  * [6.5 Priority queues](Chapter_06_Heapsort/exercises_6.5.ipynb)
  * [Problems](Chapter_06_Heapsort/problems.ipynb)

* 7 Quicksort
  * [7.1 Description of quicksort](Chapter_07_Quicksort/exercises_7.1.ipynb)
  * [7.2 Performance of quicksort](Chapter_07_Quicksort/exercises_7.2.ipynb)
  * [7.3 A randomized version of quicksort](Chapter_07_Quicksort/exercises_7.3.ipynb)
  * [7.4 Analysis of quicksort](Chapter_07_Quicksort/exercises_7.4.ipynb)
  * [Problems](Chapter_07_Quicksort/problems.ipynb)

* 8 Sorting in Linear Time
  * [8.1 Lower bounds for sorting](Chapter_08_Sorting_in_Linear_Time/exercises_8.1.ipynb)
  * [8.2 Counting sort](Chapter_08_Sorting_in_Linear_Time/exercises_8.2.ipynb)
  * [8.3 Radix sort](Chapter_08_Sorting_in_Linear_Time/exercises_8.3.ipynb)
  * [8.4 Bucket sort](Chapter_08_Sorting_in_Linear_Time/exercises_8.4.ipynb)
  * [Problems](Chapter_08_Sorting_in_Linear_Time/problems.ipynb)

* 9 Medians and Order Statistics
  * [9.1 Minimum and maximum](Chapter_09_Medians_and_Order_Statistics/exercises_9.1.ipynb)
  * [9.2 Selection in expected linear time](Chapter_09_Medians_and_Order_Statistics/exercises_9.2.ipynb)
  * [9.3 Selection in worst-case linear time](Chapter_09_Medians_and_Order_Statistics/exercises_9.3.ipynb)
  * [Problems](Chapter_09_Medians_and_Order_Statistics/problems.ipynb)


## III Data Structures

* 10 Elementary Data Structures
  * [10.1 Stacks and queues](Chapter_10_Elementary_Data_Structures/exercises_10.1.ipynb)
  * [10.2 Linked lists](Chapter_10_Elementary_Data_Structures/exercises_10.2.ipynb)
  * [10.3 Implementing pointers and objects](Chapter_10_Elementary_Data_Structures/exercises_10.3.ipynb)
  * [10.4 Representing rooted trees](Chapter_10_Elementary_Data_Structures/exercises_10.4.ipynb)
  * [Problems](Chapter_10_Elementary_Data_Structures/problems.ipynb)

* 11 Hash Tables
  * [11.1 Direct-address tables](Chapter_11_Hash_Tables/exercises_11.1.ipynb)
  * [11.2 Hash tables](Chapter_11_Hash_Tables/exercises_11.2.ipynb)
  * [11.3 Hash functions](Chapter_11_Hash_Tables/exercises_11.3.ipynb)
  * [11.4 Open addressing](Chapter_11_Hash_Tables/exercises_11.4.ipynb)
  * [11.5 Perfect hashing](Chapter_11_Hash_Tables/exercises_11.5.ipynb)
  * [Problems](Chapter_11_Hash_Tables/problems.ipynb)

* 12 Binary Search Trees
  * [12.1 What is a binary search tree?](Chapter_12_Binary_Search_Trees/exercises_12.1.ipynb)
  * [12.2 Querying a binary search tree](Chapter_12_Binary_Search_Trees/exercises_12.2.ipynb)
  * [12.3 Insertion and deletion](Chapter_12_Binary_Search_Trees/exercises_12.3.ipynb)
  * [12.4 Randomly built binary search trees](Chapter_12_Binary_Search_Trees/exercises_12.4.ipynb)
  * [Problems](Chapter_12_Binary_Search_Trees/problems.ipynb)

* 13 Red-Black Trees
  * [13.1 Properties of red-black trees](Chapter_13_Red-Black_Trees/exercises_13.1.ipynb)
  * [13.2 Rotations](Chapter_13_Red-Black_Trees/exercises_13.2.ipynb)
  * [13.3 Insertion](Chapter_13_Red-Black_Trees/exercises_13.3.ipynb)
  * [13.4 Deletion](Chapter_13_Red-Black_Trees/exercises_13.4.ipynb)
  * [Problems](Chapter_13_Red-Black_Trees/problems.ipynb)

* 14 Augmenting Data Structures
  * [14.1 Dynamic order statistics](Chapter_14_Augmenting_Data_Structures/exercises_14.1.ipynb)
  * [14.2 How to augment a data structure](Chapter_14_Augmenting_Data_Structures/exercises_14.2.ipynb)
  * [14.3 Interval trees](Chapter_14_Augmenting_Data_Structures/exercises_14.3.ipynb)
  * [Problems](Chapter_14_Augmenting_Data_Structures/problems.ipynb)


## IV Advanced Design and Analysis Techniques

* 15 Dynamic Programming
  * [15.1 Rod cutting](Chapter_15_Dynamic_Programming/exercises_15.1.ipynb)
  * [15.2 Matrix-chain multiplication](Chapter_15_Dynamic_Programming/exercises_15.2.ipynb)
  * [15.3 Elements of dynamic programming](Chapter_15_Dynamic_Programming/exercises_15.3.ipynb)
  * [15.4 Longest common subsequence](Chapter_15_Dynamic_Programming/exercises_15.4.ipynb)
  * [15.5 Optimal binary search trees](Chapter_15_Dynamic_Programming/exercises_15.5.ipynb)
  * [Problems](Chapter_15_Dynamic_Programming/problems.ipynb)

* 16 Greedy Algorithm
  * [16.1 An activity-selection problem](Chapter_16_Greedy_Algorithm/exercises_16.1.ipynb)
  * [16.2 Elements of the greedy strategy](Chapter_16_Greedy_Algorithm/exercises_16.2.ipynb)
  * [16.3 Huffman codes](Chapter_16_Greedy_Algorithm/exercises_16.3.ipynb)
  * 16.4 Matroids and greedy methods
  * [16.5 A task-scheduling problem as a matroid](Chapter_16_Greedy_Algorithm/exercises_16.5.ipynb)
  * Problems

* 17 Amortized Analysis
  * [17.1 Aggregate analysis](Chapter_17_Amortized_Analysis/exercises_17.1.ipynb)
  * [17.2 The accounting method](Chapter_17_Amortized_Analysis/exercises_17.2.ipynb)
  * [17.3 The potential method](Chapter_17_Amortized_Analysis/exercises_17.3.ipynb)
  * [17.4 Dynamic tables](Chapter_17_Amortized_Analysis/exercises_17.4.ipynb)
  * [Problems](Chapter_17_Amortized_Analysis/problems.ipynb)


## V Advanced Data Structures

* 18 B-Trees
  * [18.1 Definition of B-trees](Chapter_18_B-Trees/exercises_18.1.ipynb)
  * [18.2 Basic operations on B-trees](Chapter_18_B-Trees/exercises_18.2.ipynb)
  * [18.3 Deleting a key from a B-tree](Chapter_18_B-Trees/exercises_18.3.ipynb)
  * [Problems](Chapter_18_B-Trees/problems.ipynb)

* 19 Fibonacci Heaps
  * 19.1 Structure of Fibonacci heaps
  * [19.2 Mergeable-heap operations](Chapter_19_Fibonacci_Heaps/exercises_19.2.ipynb)
  * 19.3 Decreasing a key and deleting a node
  * [19.4 Bounding the maximum degree](Chapter_19_Fibonacci_Heaps/exercises_19.4.ipynb)
  * [Problems](Chapter_19_Fibonacci_Heaps/problems.ipynb)

* 20 van Emde Boas Trees
  * [20.1 Preliminary approaches](Chapter_20_van_Emde_Boas_Trees/exercises_20.1.ipynb)
  * [20.2 A recursive structure](Chapter_20_van_Emde_Boas_Trees/exercises_20.2.ipynb)
  * [20.3 The van Emde Boas tree](Chapter_20_van_Emde_Boas_Trees/exercises_20.3.ipynb)
  * [Problems](Chapter_20_van_Emde_Boas_Trees/problems.ipynb)

* 21 Data Structures for Disjoint Sets
  * [21.1 Disjoint-set operations](Chapter_21_Data_Structures_for_Disjoint_Sets/exercises_21.1.ipynb)
  * [21.2 Linked-list representation of disjoint sets](Chapter_21_Data_Structures_for_Disjoint_Sets/exercises_21.2.ipynb)
  * [21.3 Disjoint-set forests](Chapter_21_Data_Structures_for_Disjoint_Sets/exercises_21.3.ipynb)
  * [21.4 Analysis of union by rank with path compression](Chapter_21_Data_Structures_for_Disjoint_Sets/exercises_21.4.ipynb)
  * [Problems](Chapter_21_Data_Structures_for_Disjoint_Sets/problems.ipynb)


## VI Graph Algorithms

* 22 Elementary Graph Algorithms
  * [22.1 Representations of graphs](Chapter_22_Elementary_Graph_Algorithms/exercises_22.1.ipynb)
  * [22.2 Breadth-first search](Chapter_22_Elementary_Graph_Algorithms/exercises_22.2.ipynb)
  * [22.3 Depth-first search](Chapter_22_Elementary_Graph_Algorithms/exercises_22.3.ipynb)
  * [22.4 Topological sort](Chapter_22_Elementary_Graph_Algorithms/exercises_22.4.ipynb)
  * [22.5 Strongly connected components](Chapter_22_Elementary_Graph_Algorithms/exercises_22.5.ipynb)
  * [Problems](Chapter_22_Elementary_Graph_Algorithms/problems.ipynb)

* 23 Minimum Spanning Trees
  * [23.1 Growing a minimum spanning tree](Chapter_23_Minimum_Spanning_Trees/exercises_23.1.ipynb)
  * [23.2 The algorithms of Kruskal and Prim](Chapter_23_Minimum_Spanning_Trees/exercises_23.2.ipynb)
  * [Problems](Chapter_23_Minimum_Spanning_Trees/problems.ipynb)

* 24 Single-Source Shortest Paths
  * [24.1 The Bellman-Ford algorithm](Chapter_24_Single-Source_Shortest_Paths/exercises_24.1.ipynb)
  * [24.2 Single-source shortest paths in directed acyclic graphs](Chapter_24_Single-Source_Shortest_Paths/exercises_24.2.ipynb)
  * [24.3 Dijkstra's algorithm](Chapter_24_Single-Source_Shortest_Paths/exercises_24.3.ipynb)
  * 24.4 Difference constraints and shortest paths
  * 24.5 Proofs of shortest-paths properties
  * Problems

* 25 All-Pairs Shortest Paths
  * [25.1 Shortest paths and matrix multiplication](Chapter_25_All-Pairs_Shortest_Paths/exercises_25.1.ipynb)
  * [25.2 The Floyd-Warshall algorithm](Chapter_25_All-Pairs_Shortest_Paths/exercises_25.2.ipynb)
  * [25.3 Johnson's algorithm for sparse graphs](Chapter_25_All-Pairs_Shortest_Paths/exercises_25.3.ipynb)
  * [Problems](Chapter_25_All-Pairs_Shortest_Paths/problems.ipynb)

* 26 Maximum Flow
  * [26.1 Flow networks](Chapter_26_Maximum_Flow/exercises_26.1.ipynb)
  * [26.2 The Ford-Fulkerson method](Chapter_26_Maximum_Flow/exercises_26.2.ipynb)
  * 26.3 Maximum bipartite matching
  * 26.4 Push-relabel algorithms
  * 26.5 The relabel-to-front algorithm
  * Problems


## VII Selected Topics

* 27 Multithreaded Algorithms
  * [27.1 The basics of dynamic multithreading](Chapter_27_Multithreaded_Algorithms/exercises_27.1.ipynb)
  * [27.2 Multithreaded matrix multiplication](Chapter_27_Multithreaded_Algorithms/exercises_27.2.ipynb)
  * [27.3 Multithreaded merge sort](Chapter_27_Multithreaded_Algorithms/exercises_27.3.ipynb)
  * [Problems](Chapter_27_Multithreaded_Algorithms/problems.ipynb)

* 28 Matrix Operations
  * 28.1 Solving systems of linear equations
  * 28.2 Inverting matrices
  * 28.3 Symmetric positive-definite matrices and least-squares approximation
  * Problems

* 29 Linear Programming
  * 29.1 Standard and slack forms
  * 29.2 Formulating problems as linear programs
  * 29.3 The simplex algorithm
  * 29.4 Duality
  * 29.5 The initial basic feasible solution
  * Problems

* 30 Polynomials and the FFT
  * 30.1 Representing polynomials
  * 30.2 The DFT and FFT
  * 30.3 Efficient FFT implementations
  * Problems

* 31 Number-Theoretic Algorithms
  * [31.1 Elementary number-theoretic notions](Chapter_31_Number-Theoretic_Algorithms/exercises_31.1.ipynb)
  * [31.2 Greatest common divisor](Chapter_31_Number-Theoretic_Algorithms/exercises_31.2.ipynb)
  * [31.3 Modular arithmetic](Chapter_31_Number-Theoretic_Algorithms/exercises_31.3.ipynb)
  * [31.4 Solving modular linear equations](Chapter_31_Number-Theoretic_Algorithms/exercises_31.4.ipynb)
  * [31.5 The Chinese remainder theorem](Chapter_31_Number-Theoretic_Algorithms/exercises_31.5.ipynb)
  * [31.6 Powers of an element](Chapter_31_Number-Theoretic_Algorithms/exercises_31.6.ipynb)
  * [31.7 The RSA public-key cryptosystem](Chapter_31_Number-Theoretic_Algorithms/exercises_31.7.ipynb)
  * [31.8 Primality testing](Chapter_31_Number-Theoretic_Algorithms/exercises_31.8.ipynb)
  * [31.9 Integer factorization](Chapter_31_Number-Theoretic_Algorithms/exercises_31.9.ipynb)
  * [Problems](Chapter_31_Number-Theoretic_Algorithms/problems.ipynb)

* 32 String Matching
  * [32.1 The naive string-matching algorithm](Chapter_32_String_Matching/exercises_32.1.ipynb)
  * [32.2 The Rabin-Karp algorithm](Chapter_32_String_Matching/exercises_32.2.ipynb)
  * [32.3 String matching with finite automata](Chapter_32_String_Matching/exercises_32.3.ipynb)
  * [32.4 The Knuth-Morris-Pratt algorithm](Chapter_32_String_Matching/exercises_32.4.ipynb)
  * [Problems](Chapter_32_String_Matching/problems.ipynb)

* 33 Computational Geometry
  * [33.1 Line-segment properties](Chapter_33_Computational_Geometry/exercises_33.1.ipynb)
  * [33.2 Determining whether any pair of segments intersects](Chapter_33_Computational_Geometry/exercises_33.2.ipynb)
  * 33.3 Finding the convex hull
  * 33.4 Finding the closest pair of points
  * Problems

* 34 NP-Completeness
  * 34.1 Polynomial time
  * 34.2 Polynomial-time verification
  * 34.3 NP-completeness and reducibility
  * 34.4 NP-completeness proofs
  * 34.5 NP-complete problems
  * Problems

* 35 Approximation Algorithms
  * 35.1 The vertex-cover problem
  * 35.2 The traveling-salesman problems
  * 35.3 The set-covering problem
  * 35.4 Randomization and linear programming
  * 35.5 The subset-sum problem
  * Problem
